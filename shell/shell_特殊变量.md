# shell 特殊变量特殊字符

### 通配符

通配符于base正则重合度很高，列表如下：

符号    | 意义
------ | ------
*  | 代表0到无穷多个任意字符
?  | 代表一个任意字符
[] | 代表括号内的任意字符，[123]代表1,2,3中的任意一个字符
[-] | 代表顺序编码内的任意字符，[0-9]代表0到9之间的任意一个字符
[^] | 第一个字符^表示原项选择，例如[^abc]代表除a,b,c之外的所有字符


### 特殊符号

符号       | 内容
--------- | 
\# | 注释符号<br>1.在shell文件的行首，作为include标记，#!/bin/bash; <br>2. 其他地方作为注释使用，在一行中，#后面的内容并不会被执行; <br>3.但是用单/双引号包围时，#作为#号字符本身，不具有注释作用。
\  | 反斜线，反斜杆<br>1.放在特殊符号之前，转义特殊符号的作用，仅表示特殊符号本身，这在字符串中常用；<br>2.放在一行指令的最末端，表示紧接着的回车无效（其实也就是转义了Enter），后继新行的输入仍然作为当前指令的一部分。
\| | 管道
;  | 连续执行命令的分隔符
;; | 连续分号(Terminator [double semicolon])。在使用case选项的时候，作为每个选项的终结符。在Bash version 4+ 的时候，还可以使用[;;&], [;&]
.  | 点号(dot command [period])。<br>1. 相当于bash内建命令source; <br>2. 作为文件名的一部分，在文件名的开头，表示该文件为隐藏文件，ls一般不显示出来（ls -a 可以显示）；<br>3. 作为目录名，一个点代表当前目录，两个点号代表上层目录（当前目录的父目录）。注意，两个以上的点不出现，除非你用引号（单/双）包围作为点号字符本身；<br>4. 正则表达式中，点号表示任意一个字符。
*  | 星号（wildcard/arithmetic operator[asterisk])。<br>1. 作为匹配文件名扩展的一个通配符，能自动匹配给定目录下的每一个文件；<br>2.正则表达式中可以作为字符限定符，表示其前面的匹配规则匹配任意次；<br>3. 算术运算中表示乘法。
** | 双星号(double asterisk)。算术运算中表示求幂运算。
~  | 用户的主目录
~+ | 当前工作目录
~- | 先前工作目录
$  | 使用变量的前导符
${}| 参数替换(Variable substitution)
&  | 作业控制，将作业变为背景下执行
&& | 与操作
\|\| | 或操作
!  | 感叹号（reverse (or negate) [bang],[exclamation mark])。取反一个测试结果或退出状态。<br>1. 表示反逻辑<br>2. 表示取反，如：`ls a[!0-9]` 表示a后面不是紧接一个数字的文件； <br>3. 在不同的环境里面，感叹号也可以出现在间接变量引用里面；<br>4. 在命令行中，可以用于历史命令机制的调用，你可以试试!$,!#，或者!-3看看，不过要注意，这点特性不能在脚本文件里面使用（被禁用）。
/  | 斜线，斜杆<br>1.作为路径的分隔符，路径中仅有一个斜杆表示根目录，以斜杆开头的路径表示从根目录开始的路径；<br>2.在作为运算符的时候，表示除法符号
\>,>> | 输出数据流定向，分别表示替换和累加
<,<< | 输入数据流
<<  | 双小于号(here-document[double less then marks])。这个也被称为Here-document，用来将后继的内容重定向到左侧命令的stdin中。<<可以节省格式化时间，别且使命令执行的处理更容易。在实作的时候只需要输入<<和终止标志符，而后（一般是回车后）你就可以输入任何内容，只要在最后的新行中输入终止标志符，即可完成数据的导入。使用here-document的时候，你可以保留空格，换行等。如果要让shell脚本更整洁一点，可以在<<和终止符之间放上一个连字符(-)。
<<< | 三个小于号(here-strings)。Here-字串和Here-document类似，here-strings语法：command [args] <<<["]$word["]；$word会展开并作为command的stdin。
<,> | 小于，大于号(ASCII Comparison)。ASCII比较，进行的是变量的ASCII比较，字串？数字?呃...这个...不就是ASCII比较么？
\<...\> | 词界符(word boundary)。这个是用在正则表达式中的一个特殊分隔符，用来标记单词的分界。比如：the会匹配there，another，them等等，如果仅仅要匹配the，就可以使用这个词界符，\<the\>就只能匹配the了。
'' | 单引号(full quoting [single quote])。单引号括住的内容，被视为单一字符串，引号内的禁止变量扩展，所有字符均作为字符本身处理（除单引号本身之外），单引号必须成对出现。
"" | 双引号（partial quoting [double quote]）。部分引用。双引号包围的内容可以允许变量扩展，也允许转义字符的存在。如果字符串内出现双引号本身，需要转义，因此不一定双引号是成对的。
`` | 反引号，命令替换。这个引号包围的为命令，可以执行包围的命令，并将执行的结果赋值给变量，也可使用$()
,  | 逗号。<br>1.用在连接一连串的数学表达式中，这串数学表达式均被求值，但只有最后一个求值结果被返回。<br>2.用于参数替代中，表示首字母小写，如果是两个逗号，则表示全部小写，注意，这个特性在bash version 4的时候被添加的。
:  | 冒号(null command [colon])。空命令，这个命令什么都不做，但是有返回值，返回值为0（即：true）。这个命令的作用非常奇妙。<br>1.可做while死循环的条件；<br>2.在if分支中作为占位符（即某一分支什么都不做的时候）；<br>3.放在必须要有两元操作的地方作为分隔符；<br>4.在参数替换中为字符串变量赋值，在重定向操作(>)中，把一个文件长度截断为0（:>>这样用的时候，目标存在则什么都不做），这个只能在普通文件中使用，不能在管道，符号链接和其他特殊文件中使用；<br>5. 可以作为域分隔符，比如环境变量$PATH中，或者passwd中，都有冒号的作为域分隔符的存在。
=  | 等号(Equals)。<br>1. 赋值操作，给变量赋值，么有空格在等号两侧；<br>2. 在比较测试中作为比较符出现，这里要注意，如果在中括号中作为比较出现，需要有空格符在等号左右两侧。
-  | 减号，连字符(Hyphen/minus/dash)。<br>1. 作为选项，前缀[option, prefix]使用。用于命令或者过滤器的选项标志；操作符的前缀。<br>2.用于stdin或者stdout的重定向的源或目的[dash],注意：在实作的时候，如果文件名是以[-]开头的，那么在加上这个作为定向操作符的时候，可能会出错，此时应该为文件加上合适的前缀路径，以避免这种情况发生，同样的，在echo变量的时候，如果变量是以[-]开始，那么可能也会产生意想不到的结果，为了保险起见，可以使用双引号引用标量。还有，这种表示方法不是Bash内建的，要达到此点的这种效果，需要看你使用的软件是否支持这种操作；<br>3.表示先前的工作目录(previous working directory)，因此，如果你cd到其他目录下要放回前一个路径的时候，可以使用cd -来达到目的，其实，这里的[-]使用的是环境变量的$OLDPWD，注意：这里的[-]和前一点是不同的；<br>4. 减号或者负号，用在算术操作中。
=  | 等号(Equals)。<br>1. 赋值操作，给变量赋值，么有空格在等号两侧；<br>2. 在比较测试中作为比较符出现，这里要注意，如果在中括号中作为比较出现，需要有空格符在等号左右两侧。
+  | 加号(Plus)。<br>1. 算术操作符，表示加法；<br>2. 在正则表达式中，表示的是其前的这个匹配规则匹配最少一次;<br>3.在命令或过滤器中作为选项标记，在某些命令或者内置命令中使用+来启用某些选项，使用-来禁止；<br>4. 在参数替换(parameter substitution)中，+前缀表示替代值(当变量为空的时候，使用+后面的值)
%  | 百分号(modulo[percent sign])。<br>1.在算术运算中，这个是求模操作符，即两个数进行除法运算后的余数；<br>2. 在参数替换(parameter substitution)中，可以作为模式匹配。
() | 圆括号。<br>1， 命令组（Command group）。由一组圆括号括起来的命令是命令组，命令组中的命令实在子shell（subshell）中执行。因为是在子shell内运行，因此在括号外面是没有办法获取括号内变量的值，但反过来，命令组内是可以获取到外面的值，这点有点像局部变量和全局变量的关系，在实作中，如果碰到要cd到子目录操作，并在操作完成后要返回到当前目录的时候，可以考虑使用subshell来处理；<br>2. 用于数组的初始化。
{} | 代码块(curly brackets)。这个是匿名函数，但是又与函数不同，在代码块里面的变量在代码块后面仍能访问。注意：花括号内侧需要有空格与语句分隔。另外，在xargs -i中的话，还可以作为文本的占位符，用以标记输出文本的位置。
[] | 中括号<br>1. 测试的表示，Shell会测试在[]内的表达式，需要注意的是，[]是Shell内建的测试的一部分，而非使用外部命令/usr/bin/test的链接；<br>2.在数组的上下文中，表示数组元素，方括号内填上数组元素的位置就能获得对应位置的内容<br>3. 表示字符集的范围，在正表达式中，方括号表示该位置可以匹配的字符集范围。
[[]] | 双中括号(double brackets)。这个结构也是测试，测试[[]]之中的表达式(Shell的关键字)。这个比单中括号更能防止脚本里面的逻辑错误，比如：&&,||,<,>操作符能在一个[[]]里面测试通过，但是在[]却不能通过。[[]]里面没有文件名扩展(filename expansion）或是词分隔符(Word splitting)，但是可以用参数扩展(Parameter expansion)和命令替换(command substitution)。不用文件名通配符和像空白这样的分隔符。注意，这里面如果出现了八进制，十六进制等，shell会自动执行转换比较。
$[...] | 词表达表示整数扩展(integer expansion)，在方括号里面执行整数表达式
$(()) | 表示整数扩展,在方括号里面执行整数表达式,与$[]相同
(()) | 双括号(double parentheses)。 表示整数扩展（integer expansion）。功能和上面的$[]差不多，但是需要注意的是，$[]是会返回里面表达式的值的，而(())只是执行，并不会返回值。两者执行后如果变量值发生变化，都会影响到后继代码的运行。可对变量赋值，可以对变量进行一目操作符操作，也可以是二目，三目操作符。
(command)>,<(command) | 这是进程替换(Process Substitution)。使用的时候注意，括号和<,>之间是不能有空格的，否则报错。其作用有点类似通道，但和管道在用法上又有些不同，管道是作为子进程的方式来运行的，这个命令会在/dev/fd/下面产生类似/dev/fd/63,/dev/fd/62这类临时文件，用来传递数据。
=~ | Bash 版本3中有介绍，这个是正则表达式匹配。可用在[[]]测试中
\>\| | 强制重定向(force redirection)。这会强制重写已经存在的文件。
^  | 脱字符(caret)。<br>1. 在正则表达式中，作为一行的行首(beginning-of-line)位置标志符；<br>2. 在参数替换(Parameter substitution)中，这个用法有两种，一个脱字符(${var^})，或两个(${var^^})，分别表示第一个字母大写，全部大写的意思(Bash version >=4)。
:<< | 多行注释,格式如下<br>:<< COMMENTBLOCK<br>shell脚本代码段<br>COMMENTBLOCK<br>这里的COMMENTBLOCK可以是任意字符
空白 | 空白符(Whitespace)。空白符不仅仅是指空格(spaces)，还包括制表符(tabs)，空行(blank lines)，或者这几种的组合。可用做函数的分隔符,分隔命令或变量，空行不会影响脚本的行为，因此可以用它来规划脚本代码，以增加可读性，在内置的特殊变量$IFS可以用来针对某些命令进行输入的参数进行分割，其默认就是空白符。在字符串或变量中如果有空白符，可以使用引号来规避可能的错误。


#### 逗号的例子

```
#!/bin/bash
let t1=((a=5+1, b=7+2))
echo t1=$t1, a=$a, b=$b
## 这个$t1=$b；
```

#### here documents的例子

```
wc -w <<EOF
> This is a test.
> Apple juice.
> 100% fruit juice and no added sugar, colour or preservative.
> EOF
```
这里的EOF为标示符，标示符可以是任意字符串

如果想通过shell脚本输出一段字符到文件中，可以这样做：

```
cat > filename <<EOF
this is test
Apple Juice
100% fruit juice and no added sugar, colour or preservative.
EOF
```

#### Here strings的例子

```
var="Neither in this world nor elsewhere is there any happiness in store for him who always doubts."
grep "nor" <<<$var >/dev/null && echo "Found" || echo "Not found"

# 上面这句于下面这句效果相同
echo $var | grep -q "nor"  && echo "Found" || echo "Not found"
```

#### 进程替换的例子

```
cat <(ls)       #把<(ls)当一个临时文件，文件内容是ls的结果，cat这个临时文件
cat <(ls /tmp) <(ls /data0) #(ls /tmp)和(ls /data0)当临时变量，内容分别为目录下的值，cat这两个目录
ls >(cat)      #把>(cat)当成临时文件，ls的结果重定向到这个文件，最后这个文件被cat
some_command >(/bin/cmd_for_stdout) 2 >(/bin/cmd_for_stderr)  #用进程替换将std和err输出分别定向
\#进程替换支持嵌套
sort <(egrep -v '^#' <(paste -d: <(cut -d: -f5 /etc/passwd)  <(cut -d: -f1 /etc/passwd) ) )
```

### 特殊变量

变量     | 说明
-------- |
$$ | Shell本身的PID（ProcessID）
$! | Shell最后运行的后台Process的PID
$? | 最后运行的命令的结束代码（返回值）
$- | 使用Set命令设定的Flag一览
$* | 所有参数列表。如"\(*"用「"」括起来的情况、以"\)1 \(2 … \)n"的形式输出所有参数。所有的位置参数,被作为一个单词，注意:"$*"必须被""引用。
$@ | 与$\*同义,但是每个参数都是一个独立的""引用字串,这就意味着参数被完整地传递,并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的单词。注意:"$@"必须被""引用。
$#或者${#@}或者${#*}| 添加到Shell的参数个数
$0 | Shell本身的文件名
$n | 添加到Shell的各参数值。n为数字1-9,只能表示前9个参数，使用shift命令可以改变这个限制
$_ | 保存之前执行的命令的最后一个参数
IFS | Internal Field Seprator,内部域分隔符

下面是特殊变量的一个例子

```
\# cat ./test

\#!/bin/bash

echo "\$# \${#@} \${#*} :" $# ${#@} ${#*}
echo --------------------------

echo "\"\$*\"=\"$*\""
for n in "$*";do echo $n;done

echo --------------------------
echo "\$*="$*
for n in $*;do echo $n;done
echo --------------------------
echo "\"\$@\"=$@"
for n in "$@";do echo $n;done
echo --------------------------
echo "\$@="$@
for n in $@;do echo $n;done

\# ./test aaa bbb ccc
$# ${#@} ${#*} : 3 3 3
--------------------------
"$*"="aaa bbb ccc"
aaa bbb ccc
--------------------------
$*=aaa bbb ccc
aaa
bbb
ccc
--------------------------
"$@"=aaa bbb ccc
aaa
bbb
ccc
--------------------------
$@=aaa bbb ccc
aaa
bbb
ccc

```

下面这个例子是借助IFS将字符串转化为数组

```
OLD_IFS="$IFS" 
IFS="," 
a="one,two,three,four"
arr=($a) 
IFS="$OLD_IFS" 
for s in ${arr[@]} 
do 
    echo "$s" 
done

结果为：
one
two
three
four
```

## 参考
* http://blog.useasp.net/archive/2014/06/02/summary-of-the-special-characters-in-shell-on-linux.aspx